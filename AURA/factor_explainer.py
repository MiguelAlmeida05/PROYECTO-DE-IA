# -*- coding: utf-8 -*-
"""factor_explainer

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZkrzFIHY0o7u-pj8K1MnFK54rhbpcv2g
"""

import numpy as np
from typing import Dict
from risk_predictor import (cargar_caracteristicas_json, cargar_modelo, predecir_riesgo, MODEL_PATH)

def obtener_estimador_principal(modelo):
    if hasattr(modelo, "steps"):
        return modelo.steps[-1][1]
    return modelo

# contribuciones explicativas para el modelo de regresión lineal y random forest
def calcular_contribuciones(modelo, features, paciente):
    estimador = obtener_estimador_principal(modelo)

# caso regresión logística
    if hasattr(estimador, "coef_"):
        coefs = estimador.coef_.ravel()
        contribuciones = []

        for i, feat in enumerate(features):
            valor = float(paciente[feat])
            contrib = coefs[i] * valor

            contribuciones.append({
                "feature": feat,
                "signed_contribution": contrib,
                "direction": "Incrementa" if contrib > 0 else "Disminuye" if contrib < 0 else "Neutral",
                "score": abs(contrib)})

        return contribuciones

# caso Random Forest
    if hasattr(estimador, "feature_importances_"):
        importances = estimador.feature_importances_
        contribuciones = []

        for i, feat in enumerate(features):
            valor = float(paciente[feat])
            score = importances[i] * abs(valor)

            contribuciones.append({
                "feature": feat,
                "signed_contribution": score,
                "direction": "Más influyente" if importances[i] > np.mean(importances) else "Menos influyente",
                "score": score
            })

        return contribuciones

# si es deconocido
    raise ValueError("El modelo no tiene coef_ ni feature_importances_. No se puede explicar.")


def explicacion_por_cada_factor(paciente: Dict[str, float], model_path: str = MODEL_PATH, top_k: int = 3):
    features = cargar_caracteristicas_json()
    modelo = cargar_modelo(model_path)

    # Calcular contribuciones según el tipo de modelo
    contribuciones = calcular_contribuciones(modelo, features, paciente)

    # Ordenar por impacto
    contribuciones.sort(key=lambda x: x["score"], reverse=True)

    # Obtener probabilidad real del modelo
    pred = predecir_riesgo(paciente, model_path=model_path)
    prob = pred["probability"]

# recomendaciones explicadas
    recomendaciones = []

    # fracción de eyección
    if paciente["ejection_fraction"] < 40:
        recomendaciones.append(f"La fracción de eyección mide el porcentaje de sangre que expulsa el corazón en cada latido. Por lo que, un valor \n"
         "por debajo del 40% indica que el corazón puede estar debilitado y bombea menos sangre de la cual es necesaria. \n"
         "Esto incrementa el riesgo de insuficiencia cardíaca y las complicaciones asociadas a aquella \n"
         "La fracción de eyección del paciente es: {paciente['ejection_fraction']} , por lo que se recomienda que se realice \n"
         "una evaluación cardiológica.")
    else:
        recomendaciones.append(f"La fracción de eyección mide el porcentaje de sangre que expulsa el corazón en cada latido. \n"
        "La fracción de eyección del paciente es: {paciente['ejection_fraction']}%, esta se encuentra dentro del rango normal. \n"
        "Es decir que el corazón está bombeando de manera adecuada y su función de expulsión sanguínea es saludable.")


    # nivel de sodio
    if paciente["serum_sodium"] < 135:
        recomendaciones.append(f"Los bajos niveles de sodio puede estar relacionado con la retención de líquidos, el uso de diuréticos o la disminución de la función cardíaca.\n"
        "El nivel sérico de la persona evaluada es: {paciente['serum_sodium']} mEq/L, por lo que, está debajo del rango normal de: (135–145 mEq/L). \n"
        "Además, lLa hiponatremia es un marcador clínico para la insuficiencia cardíaca.")
    else:
        recomendaciones.append(f"El nivel de sodio de la persona evaluada es: {paciente['serum_sodium']} mEq/L, esto muestra que se encuentra en el rango normal. \n"
        "Además, indica un adecuado equilibrio electrolítico junto con un buen funcionamiento renal y hormonal.")

    # Creatinina sérica
    if paciente["serum_creatinine"] > 1.5:
        recomendaciones.append(f"La creatinina del paciente es: {paciente['serum_creatinine']} mg/dL, esta se encuentra por encima de los valores normales. \n"
        "Una creatinina elevada sugiere dificultades en la función renal, aquella esáa relacionada con la función del corazon, por \n"
        "lo que, una disfunción renal puede desencadenar insuficiencia cardíaca")
    else:
        recomendaciones.append(f"La creatinina del paciente es: {paciente['serum_creatinine']} mg/dL, está en el rango adecuado. \n"
        "Esto muestra que los riñones están filtrando correctamente.")

    # Edad
    if paciente["age"] > 70:
        recomendaciones.append(f"La edad de la persona evaluada es: {paciente['age']} años. \n"
        "La edad avanzada es un factor de riesgo natural ya que existen cambios estructurales en el corazón  y los vasos sanguíneos. \n"
        "Por lo que es un factor que puede aumentar la probabilidad de sufrir enfermedades cardiovasculares. Se recomienda un \n"
        "seguimiento y controles médicos frecuentes.")
    else:
        recomendaciones.append( f"El paciente tiene {paciente['age']} años, una edad en la que el riesgo cardiovascular puede mantenerse controlado \n"
        "si mantiene un estilo de vida saludable y se siguen las recomendaciones médicas. :)")


# para generar el texto de explicación
    lineas = []
    lineas.append(f"Probabilidad estimada de muerte relacionada con insuficiencia cardíaca: {prob*100:.1f}%")
    lineas.append("\nFactores más influyentes:")

    for c in contribuciones[:top_k]:
        lineas.append(f" - {c['feature']}: {c['direction']} el riesgo.")

    lineas.append("\nRecomendaciones generales:")
    for r in recomendaciones:
        lineas.append(f" - {r}")

    explicacion_texto = "\n".join(lineas)

    return {"probability": prob, "contributions": contribuciones, "explanation_text": explicacion_texto, "recommendations": recomendaciones}